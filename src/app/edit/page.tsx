"use client";

import { useState, useRef, useEffect } from "react";
import { DndProvider, useDrag, useDrop } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";
import { Plus, Trash, GripVertical } from "lucide-react";
import axios from "axios";
import Breadcrumb from "@/components/Breadcrumbs/Breadcrumb";

interface Field {
  name: string;
  label: string;
  type: string;
  required: boolean;
  options?: string[];
  wasAutoGenerated?: boolean;
}

const emptyField: Field = {
  name: "",
  label: "",
  type: "text",
  required: false,
  options: []
};

async function saveForm(fields: Field[], title: string, info: string) {
  const response = await axios.put(process.env.NEXT_PUBLIC_API_URL + "/request-body", {
    data: {
      request: fields,
      title: title,
      info: info
    }
  });
  return response.data;
}

// Function to generate the ID from the Label
const generateID = (label: string, existingNames: string[] = []) => {
  if (!label) return "";

  // Convert to lowercase, replace spaces with underscores, and remove special characters
  let id = label.toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Remove accents
    .replace(/[^\w\s]/g, "") // Remove special characters
    .replace(/\s+/g, "_"); // Replace spaces with underscores

  // Check if the ID already exists and add a number if necessary
  let newId = id;
  let counter = 1;

  while (existingNames.includes(newId)) {
    newId = `${id}_${counter}`;
    counter++;
  }

  return newId;
};

const FieldItem = ({
  field,
  index,
  fields,
  handleFieldChange,
  moveField,
  removeField
}: {
  field: Field;
  index: number;
  fields: Field[];
  handleFieldChange: (index: number, key: keyof Field, value: any) => void;
  moveField: (dragIndex: number, hoverIndex: number) => void;
  removeField: (index: number) => void;
}) => {
  const ref = useRef<HTMLDivElement>(null);

  const [{ isDragging }, drag] = useDrag(() => ({
    type: "field",
    item: { index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  }));

  const [, drop] = useDrop(() => ({
    accept: "field",
    hover(item: { index: number }, monitor) {
      if (!ref.current) {
        return;
      }
      const dragIndex = item.index;
      const hoverIndex = index;
      if (dragIndex === hoverIndex) {
        return;
      }
      moveField(dragIndex, hoverIndex);
      item.index = hoverIndex;
    },
  }));

  drag(drop(ref));

  // Generate an ID when the label changes
  const handleLabelChange = (value: string) => {
    handleFieldChange(index, "label", value);

    // If the name is empty or was auto-generated, update it
    if (!field.name || field.wasAutoGenerated) {
      const existingNames = fields.filter((f, i) => i !== index).map((f) => f.name);
      const newName = generateID(value, existingNames);
      handleFieldChange(index, "name", newName);
      handleFieldChange(index, "wasAutoGenerated", true);
    }
  };

  return (
    <div
      ref={ref}
      className={`border p-4 mb-4 rounded space-y-3 bg-white shadow ${isDragging ? 'opacity-50' : ''}`}
    >
      <div className="flex justify-between items-center mb-2">
        <div className="flex items-center">
          <GripVertical className="mr-2 text-gray-400 cursor-move" size={20} />
          <h3 className="font-medium">{field.label || "New field"}</h3>
        </div>
        <button
          onClick={() => removeField(index)}
          className="text-red-500 hover:text-red-700"
        >
          <Trash size={18} />
        </button>
      </div>

      <div className="grid md:grid-cols-1 gap-2">
        <div>
          <label className="block text-sm font-medium mb-1">Label</label>
          <input
            type="text"
            value={field.label}
            onChange={(e) => handleLabelChange(e.target.value)}
            className="w-full border rounded px-3 py-2"
            placeholder="Field name"
          />
        </div>
        {/* Name field is hidden from the UI */}
        <div>
          <label className="block text-sm font-medium mb-1">Type</label>
          <select
            value={field.type}
            onChange={(e) => handleFieldChange(index, "type", e.target.value)}
            className="w-full border rounded px-3 py-2"
          >
            <option value="text">Text</option>
            <option value="textarea">Text Area</option>
            <option value="date">Date</option>
            <option value="select">Selector</option>
            <option value="multiselect">Multi-Selector</option>
            <option value="file">File</option>
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium mb-1">Required?</label>
          <div className="flex items-center space-x-4 mt-2">
            <label className="inline-flex items-center">
              <input
                type="radio"
                checked={field.required === true}
                onChange={() => handleFieldChange(index, "required", true)}
                className="mr-2"
              />
              <span>Yes</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                checked={field.required === false}
                onChange={() => handleFieldChange(index, "required", false)}
                className="mr-2"
              />
              <span>No</span>
            </label>
          </div>
        </div>
      </div>

      {(field.type === "select" || field.type === "multiselect") && (
        <div>
          <label className="block text-sm font-medium mb-1">Options</label>
          <div className="flex items-start">
            <input
              type="text"
              value={field.options?.join(", ") || ""}
              onChange={(e) => handleFieldChange(index, "options", e.target.value)}
              className="w-full border rounded px-3 py-2"
              placeholder="Option 1, Option 2, Option 3"
            />
          </div>
          <p className="text-xs text-gray-500 mt-1">Separate options with commas</p>
        </div>
      )}
    </div>
  );
};

export default function EditPage() {
  const [fields, setFields] = useState<Field[]>([]);
  const [formTitle, setFormTitle] = useState("");
  const [formInfo, setFormInfo] = useState("");

  useEffect(() => {
    const fetchBody = async () => {
      try {
        const response = await axios.get(process.env.NEXT_PUBLIC_API_URL + "/request-body");
        const fields = response.data?.data?.request || [];
        setFormTitle(response.data?.data?.title || "");
        setFormInfo(response.data?.data?.info || "");
        setFields(fields.map((field: Field) => ({ ...field, wasAutoGenerated: false })));
      } catch (error) {
        console.error("Error loading form body:", error);
      }
    };

    fetchBody();
  }, []);

  const handleFieldChange = (index: number, key: keyof Field, value: any) => {
    const updated = [...fields];
    if (key === "options") {
      (updated[index][key] as string[]) = value.split(",").map((opt: string) => opt.trim());
    } else {
      (updated[index][key] as string) = value;
    }
    setFields(updated);
  };

  const addField = () => {
    setFields([...fields, { ...emptyField, wasAutoGenerated: true }]);
  };

  const removeField = (index: number) => {
    const updated = [...fields];
    updated.splice(index, 1);
    setFields(updated);
  };

  const moveField = (dragIndex: number, hoverIndex: number) => {
    const updated = [...fields];
    const draggedItem = updated[dragIndex];
    updated.splice(dragIndex, 1);
    updated.splice(hoverIndex, 0, draggedItem);
    setFields(updated);
  };

  return (
    <DndProvider backend={HTML5Backend}>
      <Breadcrumb pageName="Form Editor" />
      <div className="relative mx-auto w-full px-4 py-10">
        <div className="mb-6 flex items-center justify-between">
          <h1 className="text-2xl font-bold"></h1>
          <button
            className="rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700"
            onClick={() => {
              // Remove the wasAutoGenerated property before saving
              const cleanFields = fields.map(
                ({ wasAutoGenerated, ...rest }) => rest,
              );
              saveForm(cleanFields, formTitle, formInfo);
            }}
          >
            Save form
          </button>
        </div>

        <h3 className="mb-4 text-xl font-semibold">Head:</h3>
        <div className="mb-4 flex justify-between gap-4">
          <div className="w-full">
            <label className="mb-1 block text-sm font-medium">Title</label>
            <input
              type="text"
              value={formTitle || ""}
              onChange={(e) => setFormTitle(e.target.value)}
              className="mb-6 w-full rounded border px-3 py-2"
              placeholder="Form title"
            />
          </div>

          <div className="w-full">
            <label className="mb-1 text-sm font-medium">Info</label>
            <textarea
              value={formInfo || ""}
              onChange={(e) => setFormInfo(e.target.value)}
              className="mb-6 h-32 w-full resize-y rounded border px-3 py-2"
              placeholder="Form info"
            />
          </div>
        </div>

        <h3 className="mb-4 text-xl font-semibold">Fields:</h3>
        <div className="mb-6">
          {fields.map((field, index) => (
            <FieldItem
              key={index}
              field={field}
              index={index}
              fields={fields}
              handleFieldChange={handleFieldChange}
              moveField={moveField}
              removeField={removeField}
            />
          ))}
        </div>

        <button
          onClick={addField}
          className="flex w-full items-center justify-center rounded-md border-2 border-dashed border-gray-300 py-3 text-gray-600 transition-colors hover:border-blue-500 hover:text-blue-500"
        >
          <Plus size={20} className="mr-2" />
          <span>Add new field</span>
        </button>
      </div>
    </DndProvider>
  );
}
